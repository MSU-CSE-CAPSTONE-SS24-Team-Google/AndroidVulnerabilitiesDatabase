import { Component, ViewChild, OnInit } from '@angular/core';
import { NgxChartsModule  } from '@swimlane/ngx-charts';
import { Router } from '@angular/router';
import { CommonModule } from '@angular/common';
import { multi } from './data'; // Sample data
import { MatCardModule } from '@angular/material/card';
import { ApiService } from '../api.service';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';





@Component({
  selector: 'app-line-chart',
  standalone: true,
  imports: [CommonModule, NgxChartsModule, MatCardModule, MatProgressSpinnerModule],
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit{
  multi = multi;

  view: [number, number] = [1000, 400];

  // Options
  showXAxis = true;
  showYAxis = true;
  gradient = false;
  showLegend = true;
  showXAxisLabel = true;
  xAxisLabel = 'Time';
  showYAxisLabel = true;
  yAxisLabel = 'Indexes Into Database';
  timeline = true;

  colorScheme = {
    domain: ['#5AA454', '#A10A28', '#C7B42C', '#AAAAAA'],
  };

  vulnerabilities: any;
  update_date: any;
  dataDict: { [key: string]: any } = {};
  hot_cves: any;

  

  getSeverityColor(baseScore: number): string {
    if (baseScore >= 7) {
      return 'warn'; // Use Angular Material warn color for high severity
    } else if (baseScore >= 4) {
      return 'accent'; // Use Angular Material accent color for medium severity
    } else {
      return 'primary'; // Use Angular Material primary color for low severity
    }
  }

  constructor( private router: Router, private apiService: ApiService) {

  }





  ngOnInit(): void {
    this.apiService.getDataRange("2023-10", "2024-3").subscribe({
      next: (asbdata) => {
        this.vulnerabilities = asbdata["results"].slice(1, 20);
        
      }
    });

    this.apiService.getUpdateLog().subscribe({
      next: (date) => {
        this.update_date = date["results"]["date"];
        
      }
    });

    this.apiService.getTrends().subscribe({
      next: (response) => {
        response.dimension_headers.forEach((dimension: any) => {
          this.dataDict[dimension.name] = [];
        });

        response.rows.forEach((row: any) => {
          for (const dimensionKey in row.dimensions) {
            if (row.dimensions.hasOwnProperty(dimensionKey)) {
              if (row.dimensions[dimensionKey].includes('CVE') && !row.dimensions['fullPageUrl'].includes('localhost')) {
                const url = row.dimensions[dimensionKey];
                const segments = url.split('/');

                // Get the last segment
                const lastSegment = segments[segments.length - 1];

                // Extract the CVE string
                const cve = lastSegment.substring(lastSegment.lastIndexOf('/') + 1);
                this.dataDict[dimensionKey].push(cve);
                // this.hot_cves.push(cve);
              }
            }
          }

          for (const metricKey in row.metrics) {
            if (row.metrics.hasOwnProperty(metricKey)) {
              if (row.dimensions['fullPageUrl'].includes('CVE') && !row.dimensions['fullPageUrl'].includes('localhost')) {
                this.dataDict[metricKey] = this.dataDict[metricKey] || [];
                this.dataDict[metricKey].push(row.metrics[metricKey]);
              }
            }
          }
        });

        
      }
    })
  }

  goToDetailsPage(vulnerability: any) {
    this.router.navigate(['/details/', vulnerability]);
  }

  getVulnerability(URL : any) {
    console.log(URL);
  }

  calculateBackgroundColor(views: number): string {
    // Calculate the color based on the number of views
    // For example, you can use a gradient from light blue to dark blue
    // Adjust the logic as per your requirements
    const maxViews = 50; // Adjust this based on your data
    const minColor = [173, 216, 230]; // Light blue color
    const maxColor = [0, 0, 139]; // Dark blue color
  
    const normalizedViews = Math.min(views, maxViews) / maxViews;
    const color = minColor.map((channel, index) =>
      Math.round(channel + normalizedViews * (maxColor[index] - channel))
    );
    return `rgb(${color.join(',')})`;
  }
}