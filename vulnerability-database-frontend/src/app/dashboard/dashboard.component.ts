import { Component, OnInit, ViewChild, AfterViewInit, ViewChildren, QueryList, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgChartsModule, BaseChartDirective } from 'ng2-charts';
import { ApiService } from '../api.service';
import { HttpClientModule } from '@angular/common/http';
import { MatIconModule } from '@angular/material/icon';
import { ActivatedRoute } from '@angular/router';
import { Observable } from 'rxjs';
import { Router } from '@angular/router';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule, NgChartsModule, HttpClientModule, MatIconModule],
  templateUrl: './dashboard.component.html',
  styleUrl: './dashboard.component.css'
})
export class DashboardComponent implements OnInit, AfterViewInit {
  @ViewChildren(BaseChartDirective) charts: QueryList<BaseChartDirective>;

  asbData : any;
  sevData: Array<number> = [];
  currentPage = 0;
  totalPages = 0;
  baseScoreData: Array<number> = [];
  constructor(private apiService: ApiService, private route: ActivatedRoute, private router: Router) {}

  ngOnInit(): void {
    this.route.params.subscribe(params => {
      
      if (params['cves']){
        const cveArray = params['cves'].split(',');

        this.apiService.getMultipleCVEsData(cveArray).subscribe({
          next: (asbdata) => {
            this.handleData(asbdata);

            //update all the charts once the data is received and handled
              this.charts.forEach((child) => {
      if (child && child.chart) {
        child.chart.update();
      }
    })
          }
        })
 
    }
    else if (params['startDate'] && params['endDate'])
      {this.apiService.mergedDataAPIByDate(params['startDate'], params['endDate']).subscribe({
        next: (asbdata) => {
          this.handleData(asbdata);
        }
        
      });}
      //the default case for when someone visits dashboard with no url params
      else{
        ///constructing strings to grab the 2nd day from the previous month up to the current date to make the api call
        let prevMonth = new Date();
        prevMonth.setMonth(prevMonth.getMonth()-1);
        prevMonth.setDate(2);
        let prevMonthString = prevMonth.toISOString().slice(0,10);

        const currentDate = new Date().toISOString().slice(0,10);
        console.log(prevMonthString);
        console.log(currentDate);
        this.apiService.mergedDataAPIByDate(prevMonthString, currentDate).subscribe({
          next: (asbdata) => {
            this.handleData(asbdata);
          }
        });
      }
      });
  }
  

  //Simple function to help visualize severity data
   visualizeSeverity() :  Array<number>{
    let sevdata: Array<number> = [0, 0, 0, 0];
    for (let i = 0; i < this.asbData.results.length; i++)
    {
      if (this.asbData.results[i].severity == 'Critical')
      {
        sevdata[0] += 1;
      }
      else if(this.asbData.results[i].severity == 'High')
      {
        sevdata[1] +=1;
      }
      else if(this.asbData.results[i].severity == 'Moderate')
      {
        sevdata[2] +=1;
      }
      else if(this.asbData.results[i].severity == 'Low')
      {
        sevdata[3] +=1;
      }
    }
    return sevdata;
  }

  //simple function to help visualize base score data
  visualizeBaseScore(): Array<number>
  {
    let bsData: Array<number>= [0,0,0,0];
    for (let i = 0; i < this.asbData.results.length; i++)
    {
      if (0 < this.asbData.results[i].base_score  && this.asbData.results[i].base_score  <= 2.5)
      {
        bsData[3] += 1;
      }
      else if(2.5 < this.asbData.results[i].base_score && this.asbData.results[i].base_score  <= 5)
      {
        bsData[2] +=1;
      }
      else if(5 < this.asbData.results[i].base_score  &&this.asbData.results[i].base_score  <= 7.5)
      {
        bsData[1] +=1;
      }
      else if(7.5 < this.asbData.results[i].base_score && this.asbData.results[i].base_score  <= 10)
      {
        bsData[0] +=1;
      }
    }
    return bsData;
  }

  handleData(asbdata : Observable<any>) : void {
    this.asbData = asbdata;
    console.log(this.asbData);
    this.sevData = this.visualizeSeverity();
    this.baseScoreData = this.visualizeBaseScore();

    this.SeverityData.datasets[0].data = this.sevData;
    this.CVSSData.datasets[0].data = this.baseScoreData;
    console.log( this.SeverityData.datasets[0].data)
    this.totalPages = Math.ceil(this.asbData.results.length/10);

    

    this.charts.forEach((child) => {
      if (child && child.chart) {
        child.chart.update();
      }
    })
  }
  
  //initalizes the data that will be used in the charts on the html page
  SeverityData = {
    
    labels: ['Critical', 'High', 'Moderate', 'Low'],
    datasets: [
      {
        data: this.sevData,
      }
    ]
  };
  //define some styles/options for the charts
  SeverityOptions = {
    //these two options allow me to resize the graphs a bit
    responsive: true,
    maintainAspectRatio: false,

    plugins: {
      title: {
        display: true,
        text: 'Severity Distribution'
      },
     
    }
  };
  CVSSData = {
    
    labels: ['7.6-10', '5.1-7.5', '2.6-5','0-2.5' ],
    datasets: [
      {
        data: this.baseScoreData,
      }
    ]
  };
  
  CVSSOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      title: {
        display: true,
        text: 'Base Score Distribution'
      },
     
    }
  };

  //After initalization of the page, I want to update every single chart in the html page so that it forces a redraw with
  //data that is filled in
  ngAfterViewInit(): void {
    this.charts.forEach((child) => {
      if (child && child.chart) {
        child.chart.update();
      }
    })
  
  }
  //go to the next page in the table
  nextPage(){
    this.currentPage++;
  }
  //previous page in the table
  prevPage(){
    this.currentPage--;
  }

  //Need to make sure that you are actually able to increment the page
  hasNextPage(): boolean {
    return (this.currentPage + 1) * 10 < this.asbData.results.length;
  }

  //need to make sure you are actually able to decrement the page
  hasPrevPage(): boolean {
    return this.currentPage > 0;
  }

  //Display the first 10 api results in the table
  currentTablePage() {
    if (this.asbData.results) {
        const start = this.currentPage * 10;
        return this.asbData.results.slice(start, start + 10);
    }
    return []; // Return an empty array or handle the null case
  }

  goToDetails(cve : string) : void
  {
    this.router.navigate(['/details/',cve]);

  }

  cleanReference(reference: string): string {
    // Remove only the first and last brackets as well as the single quotes
    return reference.replace(/[\[\]']/g, '');
  }
 
  referenceLinks( ref : string, item: any ) : void
  {
    console.log(ref);
    console.log(item);
    let cleanedItem = item.replace(/[\[\]',]/g, '');


    for ( let i = 0; i < this.asbData.results.length; i++)
    {
      if (ref === this.asbData.results[i].references_)
      {
        const parsedData = JSON.parse(this.asbData.results[i].reference_links.replace(/'/g, '"'));
        console.log(parsedData);
        const referenceUrl = parsedData[cleanedItem]; 
      
        window.open(referenceUrl, "_blank"); 
      }
    }
  
   
  }
//Event listener for the left and right arrows, it will increment or decrement the table page if possible
  @HostListener('document:keydown', ['$event'])
  handleLeftRightArrows(event: KeyboardEvent) {
      if (event.key === 'ArrowLeft')
      {
        if (this.hasPrevPage())
        {
          this.prevPage();
        }
      }
      else if (event.key === 'ArrowRight')
      {
        if (this.hasNextPage())
        {
          this.nextPage();
        }
      }
  }

}
  

